int21:
	push ds
	push cs
	pop ds

	; this probably works
	mov word [tmp], bx ; cannot use stack for this
	movzx bx, ah
	shl bx, 1
	add bx, fn
	push end21 ; the proper return address
	; generated return address. should avoid any issues
	; with things like prefetch or instruction caches
	push bx
	mov bx, word [tmp]
	ret

end21:	pop ds
	iret

nul:	stc
	ret

; TODO figure out a way to format this table. maybe it can be autogenerated?
; this table is misaligned for me and im the one who made it
	;	0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F
fn:	dw	nul,	rdin_echo,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 0
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 1
	dw	nul,	nul,	nul,	nul,	nul,	setint,	nul,	nul,	nul,	nul,	nul,	nul,	gettime,	settime,	setverify,	nul	; 2
	dw	getver,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 3
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	getret,	nul,	nul	; 4
	dw	nul,	nul,	nul,	nul,	setverify,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 5
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 6
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 7
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 8
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; 9
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; A
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; B
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; C
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; D
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; E
	dw	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul,	nul	; F

tmp: dw 0
retcode: dw 0
verify: db 0

; AH = 01h
; read a character from stdin and print it to stdout
; inputs:
; 	none
; outputs:
; 	AL: character read from stdin
rdin_echo:
	push ax
	mov ah, 8
	int 0x21
	; TODO does echo go to stdout or to screen?
	pop ax
	
; AH = 4dh
; get return code
; inputs:
; 	none
; outputs:
; 	AH: termination type (0 = normal, 1 = control-C abort, 2 = critical error abort, 3 = terminate and stay resident)
; 	AL: return code
getret:
	xor ax, ax
	xchg [retcode], ax
	ret

; AH = 30h
; get the DOS version number
; inputs:
; 	none
; outputs:
; 	AL: major version
; 	AH: minor version
getver:
	mov ax, 8 ; if it is not zero indexed this indicates windows ME
	xor bx, bx ; update: what does that comment mean
	mov cx, bx
	ret


; AH = 54h
; get disk verify flag
; inputs:
; 	none
; outputs:
; 	AL: 0 if off, 1 if on
getverify:
	mov al, [verify]
	ret

; AH = 2eh
; set disk verify flag
; inputs:
; 	AL: 0 if off, 1 if on
; outputs:
; 	none
setverify:
	mov [verify], al
	ret

; AH = 35h
; get interrupt vector
; inputs:
; 	AL: interrupt number
; outputs:
; 	ES:BX: current interrupt handler
getint:
	push ds
	push di
	push ax
	xor ah, ah
	shl ax, 2
	mov di, ax
	xor ax, ax
	mov ds, ax
	pop ax
	mov word bx, [di]
	mov word es, [di+2]
	pop di
	pop ds
	ret

; AH = 25h
; set interrupt vector
; inputs:
; 	AL: interrupt number
; 	DS:DX: new interrupt handler
; outputs:
; 	none
setint:
	pusha
	xor ah, ah
	shl ax, 2
	mov di, ax
	xor ax, ax
	push es
	mov es, ax
	mov word es:[di], dx
	mov word es:[di+2], ds
	pop es
	popa
	ret

; read from CMOS register
; inputs:
; 	AL: register
; outputs:
; 	AL: value
; TODO: handle bcd here to abstract it from the kernel
rdcmos:
	cli
	cmp al, 9 ; not rtc register, do not wait. if this function bugs out
	jg .rd    ; on a century boundary thats not on me. stop using dos
	xchg al, ah
.wait:	mov al, 0xA  ; msb specifies if rtc update is in progress
	out 0x70, al ; TODO: https://wiki.osdev.org/CMOS#RTC_Update_In_Progress
	in al, 0x71
	shl al, 1
	jc .wait
	xchg al, ah
.rd:	out 0x70, al
	in al, 0x71
	sti
	ret

; write to CMOS register
; inputs:
; 	BL: value
; 	BH: register
; outputs:
; 	none
wrcmos:
	cli
	push ax
	mov al, bh
	or al, 0x80 ; nmi always on
	out 0x70, al
	mov al, bl
	out 0x71, al
	pop ax
	sti
	ret

; AH = 2ch
; read system time from the CMOS
; inputs:
; 	none
; outputs:
; 	CH: hours
; 	CL: minutes
; 	DH: seconds
gettime:
	push ax
	xor dl, dl

	mov al, dl ; seconds
	call rdcmos
	mov dh, al

	mov al, 2h ; minutes
	call rdcmos
	mov cl, al

	mov al, 4h ; hours
	call rdcmos
	mov ch, al

	shl al, 1 ; adjust for 12 hour time
	jnc .end
	add ch, 12

.end:	pop ax
	ret

; AH = 2dh
; set system time in the CMOS
; inputs:
; 	CH: hours
; 	CL: minutes
; 	DH: seconds
; outputs:
; 	none
settime:
	push bx
	mov bl, ch
	mov bh, 0x4
	call wrcmos
	mov bl, cl
	shr bh, 1
	call wrcmos
	mov bl, dh
	cmp dl, 50 ; rtc cannot hold hundredths of a second so we round
	jng .f
	inc bl
.f:	xor bh, bh
	call wrcmos
	xor al, al ; it probably succeeded, its fine. TODO: am i missing return codes anywhere else
	pop bx
	ret
